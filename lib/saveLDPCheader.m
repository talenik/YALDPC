function ret = saveLDPCheader( filename, code, encoder, decoder, folder )
% saveLDPCheader - generate header and source files out of initialized code, encoder and
% decode structures.
%
%	saveLDPCheader( filename, code, encoder, decoder, folder )
%		filename - withouth extension
%					Suggested default file 'ldpc' produces 'ldpc.h' and 'ldpc.c'
%		code	- code descriptor, see loadQCLDPC()
%		encoder	- encoder descriptor, see encodeLDPC()
%		decoder - decoder descriptor, see decodeLDPC()
%		folder - Subfolder where to store the MEX file.
%					Suggested default subfolder for MEX files is named: 'MEX'.
%
if nargin < 4
	decoder.mexclass = 'mxDOUBLE_CLASS' ;
	decoder.mexget = 'mxGetDoubles' ;
end

if nargin < 5 
	folder = '' ;
end

if ~isempty( folder )
	wd = pwd ;
	cd( folder ) ;
end

header = [ filename '.h' ] ;
source = [ filename '.c' ] ;
 
fh = fopen( header, 'w' ) ;
if fh == -1
	error([ 'Error creating file: ' header ] ) ;
end

fprintf( fh, '//This file is automatically generated by MATLAB, see createHeaderFile.m  or saveLDPCheader.m .\n\n' ) ;
fprintf( fh, '#ifndef QC_LDPC\n' ) ;
fprintf( fh, '#define QC_LDPC\n\n' ) ;
fprintf( fh, '//Communication standard: 0 > WiMAX, 1> WiFi6, 2> CCSDS, 3> 5G \n' ) ;
if isequal( code.std, 'wimax')
	std = 0 ;
elseif isequal( code.std, 'wifi6')
	std = 1 ;
elseif isequal( code.std, 'ccsds')
	std = 2 ;
end
fprintf( fh, [ '#define STD ' num2str( std ) ' \n' ] ) ;

fprintf( fh, '\n//Values in bits:\n' ) ;
fprintf( fh, [ '#define N ' num2str( code.N ) ' \n' ] ) ;
fprintf( fh, [ '#define K ' num2str( code.K ) ' \n' ] ) ;
fprintf( fh, [ '#define M ' num2str( code.M ) ' \n' ] ) ;

fprintf( fh, '\n//WIMAX: Z divisible by 4,in (24, ..., 96 ) WIFI6:  Z in ( 27, 54, 81 )\n' ) ;
fprintf( fh, [ '#define Z ' num2str( code.z ) ' \n' ] ) ;

fprintf( fh, '\n//Values in blocks of bits of size Z:\n' ) ;

fprintf( fh, [ '#define NB ' num2str( code.Nb ) ' \t// should be 24\n' ] ) ;
fprintf( fh, [ '#define KB ' num2str( code.Nb - code.Mb ) ' \n' ] ) ;
fprintf( fh, [ '#define MB ' num2str( code.Mb ) ' \n' ] ) ;

fprintf( fh, '\n//Model matrix assumed to be already scaled:\n' ) ;
fprintf( fh, [ 'extern const int8_t HBM[ MB ][ NB ] ; \n' ] ) ;

fprintf( fh, '\n//Encoder paramaters:\n' ) ;

fprintf( fh, [ 'typedef ' encoder.ctype ' WORD ;\n' ] ) ;
fprintf( fh, [ '#define WB ' num2str( encoder.wb ) ' \t\t//word size in bits\n' ] ) ;
fprintf( fh, [ '#define WBE ' num2str( log2(encoder.wb) ) ' \t\t//WB exponent: WB == 2^WBE\n' ] ) ;
fprintf( fh, [ '#define ZW ' num2str( floor( code.z / encoder.wb ) ) ' \t\t//Z in words\n' ] ) ;

NW = code.N / encoder.wb ;
%assert( isInt( NW ) ) ;
fprintf( fh, [ '#define NW ' num2str( NW ) ' \t\t//must be integral multiple of ZW\n' ] ) ;

MW = code.M / encoder.wb ;
%assert( isInt( MW ) ) ;
fprintf( fh, [ '#define MW ' num2str( MW ) ' \t\t//must be integral multiple of ZW\n' ] ) ;

KW = code.K / encoder.wb ;
fprintf( fh, [ '#define KW ' num2str( floor( KW ) ) ' \t\t//must work together with MWF\n' ] ) ;

%minimum number of data words so that buffer size is divisible by WB
MWFk = lcm( code.K, encoder.wb ) / code.K ;
%minimum number of codewords so that buffer size is divisible by WB
MWFn = lcm( code.N, encoder.wb ) / code.N ;

MWF = max( MWFk, MWFn ) ;

%fprintf( fh, [ '#define MWF ' num2str( MWF ) ' \t\t//min nr. of words in frame so that frame divisible by WB \n' ] ) ;

if strcmp( encoder.method, 'bitmap')
	fprintf( fh, "\n#define BITMAP 1 \t\t//determines 'array' or 'bitmap' implementation\n") ;
else
	fprintf( fh, "\n#undef BITMAP \t\t//determines 'array' or 'bitmap' implementation\n") ;
end

fprintf( fh, '\n#ifdef BITMAP\n' ) ;
fprintf( fh, [ '\ttypedef WORD BLOCK[ ZW ] ;\n' ] ) ;
fprintf( fh, '#else\n' ) ;
fprintf( fh, [ '\ttypedef WORD BLOCK[ Z ] ;\n' ] ) ;
fprintf( fh, '#endif\n\n' ) ;
fprintf( fh, [ 'typedef BLOCK *BLOCK_P ;\n\n' ] ) ;

fprintf( fh, '\n//Decoder parameters:\n' ) ;

fprintf( fh, [ '#define G_MAX ' num2str( code.G_MAX ) ' \n\n' ] ) ;

fprintf( fh, '\n//Index arrays:\n') ;
fprintf( fh, ['extern const int8_t CH_SI[ M ] ; \n' ] ) ;
fprintf( fh, ['extern const int16_t CH_II[ M ][ G_MAX ] ; \n' ] ) ;

if strcmp( decoder.method, 'float') 
	%floating point decoder implementation
	fprintf( fh, "#undef FIXED //determines floating point or fixed point decoder\n\n") ;
	fprintf( fh, [ 'typedef float FP ; \n' ] ) ;
	fprintf( fh, [ '#define FP_MAX FLT_MAX\n' ] ) ;
else
	%fixed point aka short int decoder implementation
	fprintf( fh, "#define FIXED 1 //determines floating point or fixed point decoder\n\n") ;
	fprintf( fh, [ 'typedef int16_t FP ; \n' ] ) ;
	fprintf( fh, [ '#define QB ' num2str( decoder.qbits ) '\n' ] ) ;
	fprintf( fh, [ '#define FP_MAX ' num2str( decoder.fp_max ) '\n' ] ) ;	
	fprintf( fh, [ '#define LMX ' num2str( decoder.llrmax ) '.0f\n' ] ) ;	
end
fprintf( fh, [ '#define N_TH ' num2str( decoder.nthread ) ' //nr. of decoder threads\n' ] ) ;

fprintf( fh, '\n//Definitions for MEX:\n' ) ;
fprintf( fh, '\n//Encoder:\n' ) ;
fprintf( fh, [ '#define UINTXY '		encoder.mextype ' \n' ] ) ;
fprintf( fh, [ '#define UINTXY_CLASS '	encoder.mexclass ' \n' ] ) ;
fprintf( fh, [ '#define GET_UINTXY '	encoder.mexget ' \n' ] ) ;
fprintf( fh, '\n' ) ;
fprintf( fh, '\n//Decoder:\n' ) ;
fprintf( fh, [ '#define FP_CLASS '	decoder.mexclass ' \n' ] ) ;
fprintf( fh, [ '#define GET_FP '	decoder.mexget ' \n' ] ) ;
fprintf( fh, '\n' ) ;


fprintf( fh, '\n#endif\n\n' ) ;

fclose( fh ) ;

fs = fopen( source, 'w' ) ;
if fs == -1
	error([ 'Error creating file: ' source ] ) ;
end

fprintf( fs, '//This file is automatically generated by MATLAB, see createHeaderFile.m or saveLDPCheader.m .\n\n' ) ;
fprintf( fs, '#include <stdint.h>\n\n') ;
fprintf( fs, '#include "ldpc.h"\n\n') ;
fclose( fs ) ;

saveAsC( code.Hbm, source, ' const int8_t HBM', '%3d', 'a', 25 ) ;

if isfield( code, 'CH_S')
	saveAsC( code.CH_S, source, ' const int8_t CH_SI', '%5d', 'a', 32 ) ;
end

if isfield( code, 'CH_I')
	saveAsC( code.CH_I, source, ' const int16_t CH_II', '%5d', 'a', 32 ) ;
end

if ~isempty( folder )
	cd( wd ) ; 
end


